import json
import os
from flask import Flask, request, jsonify
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

app = Flask(__name__)

# --- Configuration ---
SCOPES = ['https://www.googleapis.com/auth/youtube.readonly', 'https://www.googleapis.com/auth/youtube.captions.readonly']
CREDENTIALS_PATH = 'client_secret_428369234594-c93ql4k1b357nrfo3n3gh8ktlcrdi40l.apps.googleusercontent.com.json'  # Ensure this matches your downloaded client secrets file name
TOKEN_PATH = 'token.json'
API_SERVICE_NAME = 'youtube'
API_VERSION = 'v3'
DEFAULT_LANGUAGE = 'en'
SERVER_PORT = 8083
# --- End Configuration ---

def get_youtube_service():
	"""Authenticates with Google and returns the YouTube Data API service client."""
	creds = None
	# The file token.json stores the user's access and refresh tokens, and is
	# created automatically when the authorization flow completes for the first
	# time.
	if os.path.exists(TOKEN_PATH):
		creds = Credentials.from_authorized_user_file(TOKEN_PATH, SCOPES)
	# If there are no (valid) credentials available, let the user log in.
	if not creds or not creds.valid:
		if creds and creds.expired and creds.refresh_token:
			creds.refresh(Request())
		else:
			if not os.path.exists(CREDENTIALS_PATH):
				print(f"Error: Credentials file not found at {CREDENTIALS_PATH}. "
				      f"Please download your client secrets JSON file from the Google Cloud Console "
				      f"and save it as {CREDENTIALS_PATH} in the same directory as this script.")
				return None
			flow = InstalledAppFlow.from_client_secrets_file(
				CREDENTIALS_PATH, SCOPES)
			creds = flow.run_local_server(port=0)
		# Save the credentials for the next run
		with open(TOKEN_PATH, 'w') as token:
			token.write(creds.to_json())
	return build(API_SERVICE_NAME, API_VERSION, credentials=creds)

@app.route("/search_video_by_id", methods=["GET"])
def search_video_by_id():
	video_id = request.args.get("video_id")
	if not video_id:
		return jsonify({"error": "video_id parameter is required"}), 400

	youtube = get_youtube_service()
	if not youtube:
		return jsonify({"error": "Failed to authenticate with Google"}), 500

	try:
		search_response = youtube.videos().list(
			part="id,snippet",
			id=video_id
		).execute()

		if "items" not in search_response or not search_response["items"]:
			return jsonify({"error": "No video found with the provided ID"}), 404

		video_details = search_response["items"][0]
		return jsonify(video_details)
	except HttpError as e:
		return jsonify({"error": f"An HTTP error {e.resp.status} occurred: {e.content}"}), 500

@app.route("/get_captions_by_video_id", methods=["GET"])
def get_captions_by_video_id():
	video_id = request.args.get("video_id")
	language = request.args.get("language", DEFAULT_LANGUAGE)
	if not video_id:
		return jsonify({"error": "video_id parameter is required"}), 400

	youtube = get_youtube_service()
	if not youtube:
		return jsonify({"error": "Failed to authenticate with Google"}), 500

	try:
		caption_request = youtube.captions().list(
			part="snippet",
			videoId=video_id
		)
		caption_response = caption_request.execute()

		if "items" not in caption_response or not caption_response["items"]:
			return jsonify({"error": f"No captions found for video ID: {video_id}"}), 404

		found_captions = [
			caption for caption in caption_response["items"]
			if caption["snippet"]["language"] == language
		]

		if not found_captions:
			return jsonify({"error": f"No captions found in language '{language}' for video ID: {video_id}"}), 404

		caption_data_list = []
		for caption in found_captions:
			caption_data = {
				"id": caption["id"],
				"language": caption["snippet"]["language"],
				"name": caption["snippet"].get("name"),
				"is_auto_generated": caption["snippet"].get("isAutoGenerated", False)
			}
			try:
				download_request = youtube.captions().download(
					id=caption["id"],
					tfmt="srt"
				)
				download_response = download_request.execute()
				caption_data["content"] = download_response.decode("utf-8")
				caption_data_list.append(caption_data)
			except HttpError as e:
				print(f"Error downloading caption {caption['id']}: {e}")
				caption_data["content_error"] = f"Failed to download caption: {e}"
				caption_data_list.append(caption_data)

		return jsonify(caption_data_list)
	except HttpError as e:
		return jsonify({"error": f"An HTTP error {e.resp.status} occurred: {e.content}"}), 500

if __name__ == "__main__":
	print(f"Starting Flask server on port {SERVER_PORT}...")
	print("Open your browser and navigate to http://localhost:{SERVER_PORT}/")
	app.run(port=SERVER_PORT)